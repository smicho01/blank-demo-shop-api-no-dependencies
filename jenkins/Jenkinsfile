pipeline {
  agent any

//   triggers {
//     pollSCM('0 2 * * *')
//   }

  parameters {
    booleanParam(name: 'ENABLE_SERVICE_X', defaultValue: true, description: 'Enable service X')
    booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'Run the Test stage')
    booleanParam(name: 'RUN_TESTS_COVERAGE', defaultValue: true, description: 'Run the Test Coverage stage')
    booleanParam(name: 'BUILD_DOCKER_IMAGE', defaultValue: true, description: 'Build Docker image')
    booleanParam(name: 'PUSH_DOCKER_IMAGE', defaultValue: false, description: 'Push Docker image to registry')
    choice(name: 'ENVIRONMENT', choices: ['ec2-xlarge-dev1', 'ec2-xlarge-dev2', 'ec2-xlarge-prod'], description: 'Select the environment to deploy to')
    string(name: 'DEPLOY_BRANCH', defaultValue: 'master', description: 'Which branch to deploy')
    string(name: 'DOCKER_TAG', defaultValue: 'latest', description: 'Docker image tag')
  }

  environment {
    DOCKER_IMAGE_NAME = 'blank-demo-api'
    DOCKER_REGISTRY = 'your-dockerhub-username' // Update this with your Docker Hub username
    MAVEN_OPTS = '-Dmaven.repo.local=.m2/repository'
  }

  stages {
    stage('Clean Up') {
      steps {
        deleteDir()
      }
    }

    stage('Clone Repository') {
      steps {
        sh """
          git clone --branch "${params.DEPLOY_BRANCH}" --single-branch \
            https://github.com/smicho01/blank-demo-shop-api-no-dependencies.git
        """
      }
    }

    stage('Build Application') {
      steps {
        dir('blank-demo-shop-api-no-dependencies') {
          sh "mvn -B -DskipTests=true -DenableServiceX=${params.ENABLE_SERVICE_X} clean package"
        }
      }
      post {
        success {
          // Archive the built JAR file
          dir('blank-demo-shop-api-no-dependencies') {
            archiveArtifacts artifacts: 'target/*.jar', allowEmptyArchive: false
          }
        }
      }
    }

    stage('Test') {
      when {
        expression { return params.RUN_TESTS }
      }
      steps {
        dir('blank-demo-shop-api-no-dependencies') {
          sh 'mvn -B test'
        }
      }
      post {
        always {
          dir('blank-demo-shop-api-no-dependencies') {
            // Publish test results using junit step
            junit testResultsPattern: 'target/surefire-reports/*.xml', allowEmptyResults: true
          }
        }
      }
    }

    stage('Test Coverage') {
      when {
        expression { return params.RUN_TESTS_COVERAGE }
      }
      steps {
        dir('blank-demo-shop-api-no-dependencies') {
          sh 'mvn -B verify'
        }
      }
      post {
        success {
          dir('blank-demo-shop-api-no-dependencies') {
            // Publish coverage reports if JaCoCo plugin is available
            publishHTML([
              allowMissing: false,
              alwaysLinkToLastBuild: true,
              keepAll: true,
              reportDir: 'target/site/jacoco',
              reportFiles: 'index.html',
              reportName: 'JaCoCo Coverage Report'
            ])
          }
        }
      }
    }

    stage('Build Docker Image') {
      when {
        expression { return params.BUILD_DOCKER_IMAGE }
      }
      steps {
        script {
          dir('blank-demo-shop-api-no-dependencies') {
            // Build Docker image
            def imageTag = "${env.DOCKER_REGISTRY}/${env.DOCKER_IMAGE_NAME}:${params.DOCKER_TAG}"
            def buildArgs = "--build-arg ENABLE_SERVICE_X=${params.ENABLE_SERVICE_X}"

            echo "Building Docker image: ${imageTag}"
            sh "docker build ${buildArgs} -t ${imageTag} ."

            // Also tag with build number for tracking
            def buildTag = "${env.DOCKER_REGISTRY}/${env.DOCKER_IMAGE_NAME}:build-${env.BUILD_NUMBER}"
            sh "docker tag ${imageTag} ${buildTag}"

            // Store image info for later stages
            env.DOCKER_IMAGE_TAG = imageTag
            env.DOCKER_BUILD_TAG = buildTag

            echo "Docker image built successfully: ${imageTag}"
            echo "Build-specific tag: ${buildTag}"
          }
        }
      }
      post {
        success {
          echo "‚úÖ Docker image build completed"
        }
        failure {
          echo "‚ùå Docker image build failed"
        }
      }
    }

    stage('Test Docker Image') {
      when {
        expression { return params.BUILD_DOCKER_IMAGE }
      }
      steps {
        script {
          echo "Testing Docker image..."

          // Find an available port
          def testPort = sh(
            script: "python3 -c 'import socket; s=socket.socket(); s.bind((\"\", 0)); print(s.getsockname()[1]); s.close()'",
            returnStdout: true
          ).trim()

          echo "Using port ${testPort} for testing"

          // Basic smoke test - run container and check if it starts
          sh """
            # Clean up any existing test container first
            docker stop test-container-${env.BUILD_NUMBER} 2>/dev/null || true
            docker rm test-container-${env.BUILD_NUMBER} 2>/dev/null || true

            # Run container in detached mode with dynamic port
            docker run -d --name test-container-${env.BUILD_NUMBER} \
              -p ${testPort}:8080 \
              -e ENABLE_SERVICE_X=${params.ENABLE_SERVICE_X} \
              ${env.DOCKER_IMAGE_TAG}

            # Wait for container to be ready
            echo "Waiting for container to start..."
            for i in \$(seq 1 30); do
              if docker ps | grep test-container-${env.BUILD_NUMBER} > /dev/null; then
                echo "Container is running, waiting for application startup..."
                sleep 5
                break
              fi
              echo "Waiting for container... (\$i/30)"
              sleep 2
            done

            # Check container logs for any startup issues
            echo "Container logs:"
            docker logs test-container-${env.BUILD_NUMBER}

            # Wait a bit more for Spring Boot to fully start
            echo "Waiting for Spring Boot application to start..."
            sleep 20

            # Test if application is responding
            echo "Testing application health on port ${testPort}..."
            curl -f --retry 5 --retry-delay 5 --retry-connrefused http://localhost:${testPort}/customer || (
              echo "‚ùå Health check failed"
              echo "Container status:"
              docker ps -a | grep test-container-${env.BUILD_NUMBER}
              echo "Container logs:"
              docker logs test-container-${env.BUILD_NUMBER}
              exit 1
            )

            echo "‚úÖ Docker image test passed on port ${testPort}"
          """
        }
      }
      post {
        always {
          // Clean up test container
          sh """
            echo "Cleaning up test container..."
            docker logs test-container-${env.BUILD_NUMBER} || true
            docker stop test-container-${env.BUILD_NUMBER} || true
            docker rm test-container-${env.BUILD_NUMBER} || true
          """
        }
      }
    }

    stage('Push Docker Image') {
      when {
        allOf {
          expression { return params.BUILD_DOCKER_IMAGE }
          expression { return params.PUSH_DOCKER_IMAGE }
        }
      }
      steps {
        script {
          withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials',
                                          usernameVariable: 'DOCKER_USERNAME',
                                          passwordVariable: 'DOCKER_PASSWORD')]) {
            echo "Logging into Docker registry..."
            sh "echo \$DOCKER_PASSWORD | docker login -u \$DOCKER_USERNAME --password-stdin"

            echo "Pushing Docker image: ${env.DOCKER_IMAGE_TAG}"
            sh "docker push ${env.DOCKER_IMAGE_TAG}"

            echo "Pushing build-specific tag: ${env.DOCKER_BUILD_TAG}"
            sh "docker push ${env.DOCKER_BUILD_TAG}"

            echo "‚úÖ Docker images pushed successfully"
          }
        }
      }
      post {
        always {
          // Logout from Docker registry
          sh "docker logout || true"
        }
      }
    }

    stage('Deploy') {
      steps {
        echo "Deployment environment: ${params.ENVIRONMENT}"
        echo "Deploying branch: ${params.DEPLOY_BRANCH}"
        echo "Service X enabled: ${params.ENABLE_SERVICE_X}"

        script {
          if (params.BUILD_DOCKER_IMAGE) {
            echo "Docker image available: ${env.DOCKER_IMAGE_TAG}"
            echo "Build-specific tag: ${env.DOCKER_BUILD_TAG}"
          }

          if (params.ENVIRONMENT == 'ec2-xlarge-prod') {
            echo "Production deployment - additional checks required"
            // Add production-specific deployment steps
            // Example: deploy using Docker image
            if (params.BUILD_DOCKER_IMAGE) {
              echo "Would deploy Docker image: ${env.DOCKER_IMAGE_TAG}"
              // sh "docker-compose -f docker-compose.prod.yml up -d"
            }
          } else {
            echo "Development deployment"
            // Add development deployment steps
            if (params.BUILD_DOCKER_IMAGE) {
              echo "Would deploy Docker image: ${env.DOCKER_IMAGE_TAG}"
              // sh "docker run -d -p 8080:8080 ${env.DOCKER_IMAGE_TAG}"
            }
          }
        }
      }
    }
  }

  post {
    success {
      script {
        def dockerInfo = ""
        if (params.BUILD_DOCKER_IMAGE) {
          dockerInfo = "\nüê≥ Docker Image: ${env.DOCKER_IMAGE_TAG ?: 'Not built'}"
          if (params.PUSH_DOCKER_IMAGE) {
            dockerInfo += "\nüì§ Pushed to Registry: Yes"
          }
        }

        slackSend(
          channel: '#jenkins',
          color: 'good',
          message: "‚úÖ Build successful: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\n" +
                  "üåç Environment: ${params.ENVIRONMENT}\n" +
                  "üåø Branch: ${params.DEPLOY_BRANCH}\n" +
                  "‚öôÔ∏è Service X: ${params.ENABLE_SERVICE_X ? 'Enabled' : 'Disabled'}\n" +
                  "üß™ Tests: ${params.RUN_TESTS ? 'Ran' : 'Skipped'}\n" +
                  "üìä Coverage: ${params.RUN_TESTS_COVERAGE ? 'Ran' : 'Skipped'}" +
                  dockerInfo + "\n" +
                  "üîó Build URL: ${env.BUILD_URL}"
        )
      }
    }
    failure {
      script {
        def dockerInfo = ""
        if (params.BUILD_DOCKER_IMAGE) {
          dockerInfo = "\nüê≥ Docker Build: Failed"
        }

        slackSend(
          channel: '#jenkins',
          color: 'danger',
          message: "‚ùå Build failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\n" +
                  "üåç Environment: ${params.ENVIRONMENT}\n" +
                  "üåø Branch: ${params.DEPLOY_BRANCH}\n" +
                  "‚öôÔ∏è Service X: ${params.ENABLE_SERVICE_X ? 'Enabled' : 'Disabled'}\n" +
                  "üß™ Tests: ${params.RUN_TESTS ? 'Ran' : 'Skipped'}\n" +
                  "üìä Coverage: ${params.RUN_TESTS_COVERAGE ? 'Ran' : 'Skipped'}" +
                  dockerInfo + "\n" +
                  "üîó Build URL: ${env.BUILD_URL}"
        )
      }
    }
    unstable {
      slackSend(
        channel: '#jenkins',
        color: 'warning',
        message: "‚ö†Ô∏è Build unstable: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\n" +
                "üåç Environment: ${params.ENVIRONMENT}\n" +
                "üåø Branch: ${params.DEPLOY_BRANCH}\n" +
                "‚öôÔ∏è Service X: ${params.ENABLE_SERVICE_X ? 'Enabled' : 'Disabled'}\n" +
                "üß™ Tests: ${params.RUN_TESTS ? 'Ran' : 'Skipped'}\n" +
                "üìä Coverage: ${params.RUN_TESTS_COVERAGE ? 'Ran' : 'Skipped'}\n" +
                "üîó Build URL: ${env.BUILD_URL}"
      )
    }
    always {
      // Clean up Docker images to save space
      script {
        if (params.BUILD_DOCKER_IMAGE && env.DOCKER_BUILD_TAG) {
          sh """
            # Remove build-specific images to save disk space
            docker rmi ${env.DOCKER_BUILD_TAG} || true
            # Optionally remove the main tag too (uncomment if needed)
            # docker rmi ${env.DOCKER_IMAGE_TAG} || true

            # Clean up dangling images
            docker image prune -f || true
          """
        } else if (params.BUILD_DOCKER_IMAGE) {
          sh """
            # Clean up dangling images only if no specific tags to remove
            docker image prune -f || true
          """
        }
      }
      cleanWs()
    }
  }
}